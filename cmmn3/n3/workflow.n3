@prefix in: <http://n3.w3c.org/builtin/input#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.
@prefix cond: <http://rdf.org/cond#> .
@prefix state: <http://rdf.org/state#> .
@prefix cm: <http://rdf.org/cmmn#> .
@prefix re: <http://rdf.org/cmmn/reason#> .
@prefix er: <http://rdf.org/cmmn/error#> .

# - init

{
    ( ?item ?states ) cm:to ?next
} <= {
    ?item a cm:PlanItem . # tasks, stages, milestones
    _:t log:notIncludes {
        ?stage cm:hasChild ?item
    } .

    ( ?item ?states ) state:isIn ( state:Inactive ?cur ) .
    ( ?item ?states ) state:createNew ( ( state:Ready re:notInStage ) ?next ) .

    true log:callWithCut true .
} .

# - stages

{
    ( ?child ?states ) cm:to ?next
} <= {
    ?stage a cm:Stage .
    ( ?stage ?states ) state:isIn ( state:Active ?x ) .
    ?stage cm:hasChild ?child .

    ( ?child ?states ) state:isIn ( state:Inactive ?cur ) .
    ( ?child ?cur ) state:createNew ( ( state:Ready re:inActiveStage ) ?next ) . 

    true log:callWithCut true .
} .

{ ( ?item ?states ) cm:isDoneOrOptional true } <= { ?item cm:isMandatory false } .
{ ( ?item ?states ) cm:isDoneOrOptional true } <= { ( ?item ?states ) state:isIn ( state:Completed ?x ) } .

{
    ( ?stage ?states ) cm:to ?next
} <= {
    ?stage a cm:Stage .
    ( ?stage ?states ) state:isIn ( state:Active ?x ) .

    ( { ?stage cm:hasChild ?child } { ( ?child ?states ) cm:isDoneOrOptional true } )
        log:forAllIn _:t .

    ( ?stage ?states ) state:createNew ( ( state:Completed re:childrenDoneOrOptional ) ?next ) .

    true log:callWithCut true .
} .


# - sentries

# -- entry
{
    ( ?item ?states ) cm:to ?next
} <= {
    ?item cm:hasSentry ?sentry .
    ?sentry a cm:EntrySentry .
    
    ( { ?sentry cm:hasPlanItemPart ?itemPart } { ( ?itemPart!cm:hasSource ?states ) state:isIn ( state:Completed ?x ) } )
        log:forAllIn _:t .

    ( { ?sentry cm:hasCondition ?cond } { ?cond cond:conditionMet true } )
        log:forAllIn _:t .

    ( ?item ?states ) state:isIn ( state:Ready ?cur ) .
    ( ?item ?cur ) state:createNew ( ( state:Active re:sentryFired ) ?next ) .

    true log:callWithCut true .
} .

{
    ( ?item ?states ) cm:to ?next
} <= {
    ?item a cm:PlanItem .
    ( ?sentry { ?item cm:hasSentry ?sentry . ?sentry a cm:EntrySentry } () ) log:collectAllIn _:t .
    
    ( ?item ?states ) state:isIn ( state:Ready ?cur ) .
    ( ?item ?cur ) state:createNew ( ( state:Active re:noSentries ) ?next ) .

    true log:callWithCut true .
} .

# -- exit
# TODO


# -- default

{
    ( ?item ?states ) cm:to ?cur
} <= {
    ( ?item ?states ) state:isIn ( ?t ?cur ) . 

    true log:callWithCut true .
} .


# - error checking

# mistakes:
# - a task not in ready state being completed
#       stage not respected: means their stage was not yet activated
# - a task in the ready state, but not in active state, being completed
#       sentry not respected: means one of their sentries have not yet fired
# - a completed task, not marked as recurrent, being completed again
# - mandatory tasks left incomplete after all observations

# -- per state transition
# (referred by state.n3)

{ ( ?item ?all ?new ) state:check ( ?type ( ?reason ?error ) ) } 
<= {
    ?all list:last ?prior .
    ( ?item ?prior ?new ) cm:error ?error .
    ?new log:equalTo ( ?type ( ?reason ) ) .

    true log:callWithCut true .
} .

{ ( ?item ?all ?new ) state:check ?new } <= {} . 

{ ( ?item ( state:Inactive ?d1 ) ( state:Completed ?d2 ) ) cm:error er:inactiveToCompleted } <= {} .

{ ( ?item ( state:Ready ?d1 ) ( state:Completed ?d2 ) ) cm:error er:readyToCompleted } <= {} .

{ ( ?item ( state:Completed ?d1 ) ( state:Completed ?d2 ) ) cm:error er:nonRepetitiveMultipleCompleted }
<= { ?item cm:hasRepetition false } .

# -- for final set of states
# (referred to by run.n3)

{ ?final state:checkFinal ?final2 } <= {
    ?final graph:list ?stmts .

    ( { ?item state:all ?all2 }
        {
            ?stmts list:member { ?item state:all ?all } .
            ( ?item ?all ) cm:checkFinalItem ?all2 .
        }
        ?stmts2 
    ) log:collectAllIn _:t .

    ?stmts2 log:conjunction ?final2
} .

{ ( ?item ?all ) cm:checkFinalItem ?all2 }
<= {
    ( ?first ( ( ?type ?desc ) ) ) list:append ?all .
    ( ?item ( ?type ?desc ) ) cm:lastError ?error .

    ( ?desc ( ?error ) ) list:append ?desc2 .
    ( ?first ( ( ?type ?desc2 ) ) ) list:append ?all2 .

    true log:callWithCut true
} .

{ ( ?item ?all ) cm:checkFinalItem ?all } <= {} .

{ ( ?item ( ?type ?desc ) ) cm:lastError er:mandatoryNotDone } 
<= {
    ?item cm:isMandatory true .
    ?type log:notEqualTo state:Completed .
} .