# ===================
# math builtins tests
# ===================

@prefix :      <http://example.org/math-tests#> .
@prefix math:  <http://www.w3.org/2000/10/swap/math#> .
@prefix log:   <http://www.w3.org/2000/10/swap/log#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .

# ----------------------
# Simple test vocabulary
# ----------------------
:MathBuiltinTest a :TestCaseClass .

:builtin  a :TestProperty .
:input    a :TestProperty .
:other    a :TestProperty .
:expected a :TestProperty .
:actual   a :TestProperty .
:status   a :TestProperty .

:pass     a :TestStatus .

# ------------------------------------------------------------------------
# NOTE ABOUT NUMERIC LITERALS
# ------------------------------------------------------------------------
# eyeling.js' math: builtins:
# - accept both typed and untyped numeric literals as INPUT (via parseNum)
# - RETURN untyped numeric literals (via formatNum)
#
# So in these tests:
# - Inputs may be typed or untyped (to exercise casting).
# - Expected results are written as UNTYPED numerics so that math:equalTo
#   can unify directly with the reasoner's untyped numeric results.
# ------------------------------------------------------------------------

# math:absoluteValue
{
  -2 math:absoluteValue ?abs .
  ?abs math:equalTo 2 .
}
=>
{
  :test-absoluteValue-1 a :MathBuiltinTest;
    :builtin  math:absoluteValue;
    :input    -2;
    :expected 2;
    :actual   ?abs;
    :status   :pass .
} .

{
  3 math:absoluteValue ?abs .
  ?abs math:equalTo 3 .
}
=>
{
  :test-absoluteValue-2 a :MathBuiltinTest;
    :builtin  math:absoluteValue;
    :input    3;
    :expected 3;
    :actual   ?abs;
    :status   :pass .
} .

# math:acos
{
  1 math:acos ?r .
  ?r math:equalTo 0 .
}
=>
{
  :test-acos-1 a :MathBuiltinTest;
    :builtin  math:acos;
    :input    1;
    :expected 0;
    :actual   ?r;
    :status   :pass .
} .

# math:asin
{
  0 math:asin ?r .
  ?r math:equalTo 0 .
}
=>
{
  :test-asin-1 a :MathBuiltinTest;
    :builtin  math:asin;
    :input    0;
    :expected 0;
    :actual   ?r;
    :status   :pass .
} .

# math:atan
# atan(1) = pi/4
{
  1 math:atan ?r .
  ?r math:equalTo 0.7853981633974483 .
}
=>
{
  :test-atan-1 a :MathBuiltinTest;
    :builtin  math:atan;
    :input    1;
    :expected 0.7853981633974483;
    :actual   ?r;
    :status   :pass .
} .

# math:cos
# cos(0) = 1
{
  0 math:cos ?r .
  ?r math:equalTo 1 .
}
=>
{
  :test-cos-1 a :MathBuiltinTest;
    :builtin  math:cos;
    :input    0;
    :expected 1;
    :actual   ?r;
    :status   :pass .
} .

# math:cosh
# cosh(0) = 1
{
  0 math:cosh ?r .
  ?r math:equalTo 1 .
}
=>
{
  :test-cosh-1 a :MathBuiltinTest;
    :builtin  math:cosh;
    :input    0;
    :expected 1;
    :actual   ?r;
    :status   :pass .
} .

# math:degrees
{
  3.141592653589793 math:degrees ?deg .
  ?deg math:equalTo 180 .
}
=>
{
  :test-degrees-1 a :MathBuiltinTest;
    :builtin  math:degrees;
    :input    3.141592653589793;
    :expected 180;
    :actual   ?deg;
    :status   :pass .
} .

# math:difference
{
  (7 2) math:difference ?d .
  ?d math:equalTo 5 .
}
=>
{
  :test-difference-1 a :MathBuiltinTest;
    :builtin  math:difference;
    :input    (7 2);
    :expected 5;
    :actual   ?d;
    :status   :pass .
} .

{
  (2 7) math:difference ?d .
  ?d math:equalTo -5 .
}
=>
{
  :test-difference-2 a :MathBuiltinTest;
    :builtin  math:difference;
    :input    (2 7);
    :expected -5;
    :actual   ?d;
    :status   :pass .
} .

# math:equalTo
# Positive equality test
{
  42 math:equalTo 42 .
}
=>
{
  :test-equalTo-1 a :MathBuiltinTest;
    :builtin  math:equalTo;
    :input    42;
    :other    42;
    :status   :pass .
} .

# math:exponentiation
# Forward mode: (7 2) -> 49
{
  (7 2) math:exponentiation ?r .
  ?r math:equalTo 49 .
}
=>
{
  :test-exponentiation-1 a :MathBuiltinTest;
    :builtin  math:exponentiation;
    :input    (7 2);
    :expected 49;
    :actual   ?r;
    :status   :pass .
} .

# Inverse mode: (7 ?exp) math:exponentiation 49 => ?exp = 2
{
  (7 ?exp) math:exponentiation 49 .
}
=>
{
  :test-exponentiation-2 a :MathBuiltinTest;
    :builtin  math:exponentiation;
    :input    (7 ?exp);
    :expected 2;
    :actual   ?exp;
    :status   :pass .
} .

# math:greaterThan
{
  42 math:greaterThan 41 .
}
=>
{
  :test-greaterThan-1 a :MathBuiltinTest;
    :builtin  math:greaterThan;
    :input    42;
    :other    41;
    :status   :pass .
} .

# math:integerQuotient
{ (10 3) math:integerQuotient ?q . ?q math:equalTo 3 . }
=> {
  :test-integerQuotient-1 a :MathBuiltinTest;
    :builtin math:integerQuotient;
    :input (10 3);
    :expected 3;
    :actual ?q;
    :status :pass .
} .

# math:lessThan
{
  41 math:lessThan 42 .
}
=>
{
  :test-lessThan-1 a :MathBuiltinTest;
    :builtin  math:lessThan;
    :input    41;
    :other    42;
    :status   :pass .
} .

# math:negation
# Forward mode
{
  42 math:negation ?neg .
  ?neg math:equalTo -42 .
}
=>
{
  :test-negation-1 a :MathBuiltinTest;
    :builtin  math:negation;
    :input    42;
    :expected -42;
    :actual   ?neg;
    :status   :pass .
} .

# Inverse mode: ?x math:negation 1 => ?x = -1
{
  ?x math:negation 1 .
}
=>
{
  :test-negation-2 a :MathBuiltinTest;
    :builtin  math:negation;
    :input    ?x;
    :expected -1;
    :actual   ?x;
    :status   :pass .
} .

# math:notEqualTo
{
  41 math:notEqualTo 42 .
}
=>
{
  :test-notEqualTo-1 a :MathBuiltinTest;
    :builtin  math:notEqualTo;
    :input    41;
    :other    42;
    :status   :pass .
} .

# math:notGreaterThan
{
  41 math:notGreaterThan 42 .
}
=>
{
  :test-notGreaterThan-1 a :MathBuiltinTest;
    :builtin  math:notGreaterThan;
    :input    41;
    :other    42;
    :status   :pass .
} .

# math:notLessThan
{
  42 math:notLessThan 41 .
}
=>
{
  :test-notLessThan-1 a :MathBuiltinTest;
    :builtin  math:notLessThan;
    :input    42;
    :other    41;
    :status   :pass .
} .

# math:product
{
  (2 21) math:product ?p .
  ?p math:equalTo 42 .
}
=>
{
  :test-product-1 a :MathBuiltinTest;
    :builtin  math:product;
    :input    (2 21);
    :expected 42;
    :actual   ?p;
    :status   :pass .
} .

{
  (2 4 6 8) math:product ?p .
  ?p math:equalTo 384 .
}
=>
{
  :test-product-2 a :MathBuiltinTest;
    :builtin  math:product;
    :input    (2 4 6 8);
    :expected 384;
    :actual   ?p;
    :status   :pass .
} .

# math:quotient
{
  (42 2) math:quotient ?q .
  ?q math:equalTo 21 .
}
=>
{
  :test-quotient-1 a :MathBuiltinTest;
    :builtin  math:quotient;
    :input    (42 2);
    :expected 21;
    :actual   ?q;
    :status   :pass .
} .

# math:remainder
{
  (10 3) math:remainder ?r .
  ?r math:equalTo 1 .
}
=>
{
  :test-remainder-1 a :MathBuiltinTest;
    :builtin  math:remainder;
    :input    (10 3);
    :expected 1;
    :actual   ?r;
    :status   :pass .
} .

# math:rounded
# Typed input, untyped integer output
{
  "3.3"^^xsd:double math:rounded ?r .
  ?r math:equalTo 3 .
}
=>
{
  :test-rounded-1 a :MathBuiltinTest;
    :builtin  math:rounded;
    :input    "3.3"^^xsd:double;
    :expected 3;
    :actual   ?r;
    :status   :pass .
} .

# Tie-breaking towards +infinity: 3.5 -> 4
{
  3.5 math:rounded ?r .
  ?r math:equalTo 4 .
}
=>
{
  :test-rounded-2 a :MathBuiltinTest;
    :builtin  math:rounded;
    :input    3.5;
    :expected 4;
    :actual   ?r;
    :status   :pass .
} .

# Negative tie-breaking towards +infinity: -1.5 -> -1
{
  -1.5 math:rounded ?r .
  ?r math:equalTo -1 .
}
=>
{
  :test-rounded-3 a :MathBuiltinTest;
    :builtin  math:rounded;
    :input    -1.5;
    :expected -1;
    :actual   ?r;
    :status   :pass .
} .

# math:sin
# sin(0) = 0
{
  0 math:sin ?r .
  ?r math:equalTo 0 .
}
=>
{
  :test-sin-1 a :MathBuiltinTest;
    :builtin  math:sin;
    :input    0;
    :expected 0;
    :actual   ?r;
    :status   :pass .
} .

# math:sinh
# sinh(0) = 0
{
  0 math:sinh ?r .
  ?r math:equalTo 0 .
}
=>
{
  :test-sinh-1 a :MathBuiltinTest;
    :builtin  math:sinh;
    :input    0;
    :expected 0;
    :actual   ?r;
    :status   :pass .
} .

# math:sum
{
  (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
  ?s math:equalTo 55 .
}
=>
{
  :test-sum-1 a :MathBuiltinTest;
    :builtin  math:sum;
    :input    (1 2 3 4 5 6 7 8 9 10);
    :expected 55;
    :actual   ?s;
    :status   :pass .
} .

# math:tan
# tan(0) = 0
{
  0 math:tan ?r .
  ?r math:equalTo 0 .
}
=>
{
  :test-tan-1 a :MathBuiltinTest;
    :builtin  math:tan;
    :input    0;
    :expected 0;
    :actual   ?r;
    :status   :pass .
} .

# math:tanh
# tanh(0) = 0
{
  0 math:tanh ?r .
  ?r math:equalTo 0 .
}
=>
{
  :test-tanh-1 a :MathBuiltinTest;
    :builtin  math:tanh;
    :input    0;
    :expected 0;
    :actual   ?r;
    :status   :pass .
} .

