@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix in: <http://n3.w3c.org/builtin/input#> .
@prefix list: <http://www.w3.org/2000/10/swap/list#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix cond: <http://rdf.org/cond#> .
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix graph: <http://www.w3.org/2000/10/swap/graph#>.
@prefix state: <http://rdf.org/state#> .
@prefix cm: <http://rdf.org/cmmn#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix cap: <http://ontario.org/qbp/cap#> .

{ ?prior cm:run ?final } 
<= {
    # "run prior" log:trace ?prior .
    
    ?prior cm:step ?next .
    # "run next" log:trace ?next .

    ( ?prior ?next ) cm:ctu ?final .
} .

{ ?prior cm:step ?next } 
<= {
    ( ?new 
    {
        ?item a cm:PlanItem .
        ( ?item ?prior ) cm:to ?new
    }    
    ?news ) log:collectAllIn _:t .

    ?news log:conjunction ?next .
} .

# NOTE requires comparing "entire" graph terms with each other
# can't we (easily) detect changes in the collectAllIn loop??
{ ( ?prior ?prior ) cm:ctu ?prior }
<= {
    true log:callWithCut true
} .

{ ( ?prior ?next ) cm:ctu ?final }
<= {
    # "run ctu" log:trace "ctu" .
    ?next cm:run ?final
} .


{ ( ?trace ?states ) cm:runThroughTrace ?final } 
<= {
    ?trace e:firstRest ( ( ?item ?type ?reason ) ?trace2 ) .
    
    ( ?item ?states ) state:isIn ( ?t ?obs0 ) .
    ( ?item ?states ) state:createNew ( ( ?type ?reason ) ?obs ) .
    # "obs" log:trace ?obs .

    ( ?states ?obs0 ?obs ) graph:replace ?states2 .

    ?states2 cm:run ?states3 .

    ( ?trace2 ?states3 ) cm:runThroughTrace ?final
} .

{ ( () ?states ) cm:runThroughTrace ?states } <= {} . 

{ ?item cm:label ?item } <= { _:t log:notIncludes { ?item rdfs:label ?label } } . #. ?item log:uri ?uri } .
{ ?item cm:label ?label } <= { ?item rdfs:label ?l . ( ?l " (" ?item  ")" ) string:concatenation ?label } .

{ ?states cm:prettyprint ?pp }
<= {
    ?states graph:list ?lst .
    ( { ?label state:all ?all }
        { 
            ?lst list:member { ?item state:all ?all } .
            ?item cm:label ?label
        }
      ?labelsStates
    ) log:collectAllIn _:y .

    ?labelsStates log:conjunction ?pp
} .

{
    _:x state:init ?init .
    # "init" log:trace ?init .
    ?init cm:run ?next .
    
    ?trace a cm:Trace .
    ( ?trace ?next ) cm:runThroughTrace ?final .

    ?final state:checkFinal ?final2 .
    ?final2 cm:prettyprint ?labeledStates    

} => {
    _:t :out ?labeledStates .
} .